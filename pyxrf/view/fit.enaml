from __future__ import absolute_import
import numpy as np
import six

from enaml.widgets.api import (Container, PushButton, Label,
                               Form, Field, FileDialogEx, DockItem,
                               DockArea, CheckBox, ComboBox,
                               ScrollArea, Window, GroupBox, RadioButton,
                               MainWindow)

from enaml.widgets.api import RadioButton as DefaultRadioButton

from enaml.layout.api import hbox, vbox, HSplitLayout, VSplitLayout, TabLayout, spacer
from enaml.stdlib.fields import FloatField
from enaml.layout.geometry import Box
from enaml.core.api import Include, Looper

from enaml.stdlib.fields import FloatField as DefaultFloatField
from enaml.stdlib.fields import IntField as DefaultIntField

from enaml.stdlib.dialog_buttons import DialogButton
from enaml.stdlib.message_box import critical

from ..model.guessparam import fit_strategy_list, save_as, bound_options, autofit_param
from ..model.fit_spectrum import get_cs
from ..model.fileio import sep_v

from skbeam.core.fitting.xrf_model import (K_LINE, L_LINE, M_LINE)
from skbeam.fluorescence import XrfElement as Element

try:
    import databroker
except ImportError:
    databroker = None


userpeak_list = ['Userpeak'+str(i) for i in range(1, 11)]  # 10 users peak

enamldef FloatField(DefaultFloatField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef IntField(DefaultIntField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef RadioButton(DefaultRadioButton):
    minimum_size = (80, 20)

enamldef LabelTitle(Label):
    maximum_size = 80
    align = 'left'

#bound_options = ['none', 'lohi', 'fixed', 'lo', 'hi']

enamldef FitView(DockItem): fit_view:
    attr plot_model
    attr param_model
    attr fit_model
    attr element_edit
    attr parameter_edit
    attr othersetting_edit
    attr autofind_edit
    attr img_model_adv
    attr img_model_rgb
    attr pileup_edit
    attr setting_model
    attr output_edit

    Container:
        padding = Box(2, 2, 2, 2)
        constraints = [
            vbox(
                #hbox(new_param_load, reload_btn, lbl_param, spacer),
                #hbox(lbl_param, spacer),
                load_gb,
                #hbox(auto_find_gb),
                control_element,
                fit_control,
                gb_fit_pixel,
                #hbox(fit_pixel, spacer),
            ),
        ]

        GroupBox: load_gb:
            padding = Box(2, 2, 2, 2)
            constraints = [vbox(
                                hbox(lbl_load, spacer),
                                hbox(new_param_load, saveas_btn, lbl_param, spacer),
                                #hbox(lbl_param, spacer),
                                hbox(lbl_auto, pb_auto, spacer),)
                                #hbox(pb_auto, spacer))
                           ]
            Label: lbl_load:
                text = 'Load elemental parameters from file.'
            PushButton: new_param_load:
                text = 'Import Parameters'
                #maximum_size = 200
                clicked ::

                    if fit_model.data is not None:

                        parameter_file_path = FileDialogEx.get_open_file_name(fit_view)
                        if parameter_file_path:

                            # update parameter for fit
                            fit_model.read_param_from_file(parameter_file_path)
                            fit_model.apply_default_param()

                            # update experimental plots
                            plot_model.parameters = fit_model.default_parameters
                            plot_model.plot_experiment()
                            plot_model.plot_exp_opt = False
                            plot_model.plot_exp_opt = True

                            # update autofit param
                            param_model.update_new_param(fit_model.default_parameters)
                            #param_model.get_new_param_from_file(parameter_file_path)
                            param_model.update_name_list()
                            param_model.EC.turn_on_all()

                            # update params for roi sum
                            setting_model.update_parameter(fit_model.default_parameters)

                            # update file name
                            lbl_param.text = 'Loaded file: {}'.format(parameter_file_path.split(sep_v)[-1])

                            # calculate profile and plot
                            fit_model.get_profile()

                            # update experimental plot with new calibration values
                            plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                                fit_model.cal_spectrum,
                                                fit_model.residual)
                            # For plotting purposes, otherwise plot will not update
                            plot_model.show_fit_opt = False
                            plot_model.show_fit_opt = True

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded', btns)

            Label: lbl_param:
                text = 'No parameter is loaded.'

            PushButton: saveas_btn:
                text = 'Save'
                clicked ::
                    path = FileDialogEx.get_save_file_name(fit_view,
                                                           current_path=fit_model.result_folder)
                    if path:
                        save_as(path, fit_model.param_dict)

        #GroupBox: auto_find_gb:
        #    title = 'Or use automatic element finding.'
        #    padding = Box(2, 2, 2, 2)
        #    constraints = [hbox(pb_auto, spacer)]

            Label: lbl_auto:
                text = 'Or use automatic peak finding method.'
            PushButton: pb_auto:
                text = 'Find Elements Automatically'
                enabled = True
                clicked ::
                    if fit_model.data is not None:
                        autofind_edit.show()
                    else:
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded', btns)

        GroupBox: control_element:
            title = 'Add/Remove elements (Userpeak with center energy at 5 keV can be added.).'
            padding = Box(2, 2, 2, 2)
            constraints = [
                vbox(
                    hbox(cb_select, intensity_lb, intensity_fd,
                         manual_add, spacer, pb_pileup),
                    pre_fit,
                    #hbox(saveas_btn, spacer),
                ),
            ]
            ComboBox: cb_select:
                items = ['Select Lines'] +\
                        K_LINE + L_LINE + M_LINE + userpeak_list
                index = 0
                index ::
                    if cb_select.index > 0:
                        param_model.e_name = cb_select.selected_item

            Label: intensity_lb:
                text = 'Peak Int'
            FloatField: intensity_fd:
                value := param_model.add_element_intensity
                maximum_size = 60

            PushButton: manual_add:
                text = 'Add'
                clicked ::
                    param_model.manual_input()
                    param_model.EC.update_peak_ratio()
                    param_model.update_name_list()
                    param_model.data_for_plot()

                    plot_model.plot_fit(param_model.prefit_x,
                                        param_model.total_y,
                                        param_model.auto_fit_all)
                    # For plotting purposes, otherwise plot will not update
                    plot_model.show_fit_opt = False
                    plot_model.show_fit_opt = True

            PushButton: pb_pileup:
                text = 'Add Pileup Peaks'
                enabled = True
                checkable = True
                checked := pileup_edit.visible
                clicked ::
                    if checked:
                        pileup_edit.show()
                    else:
                        pileup_edit.hide()

            GroupBox: pre_fit:
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(scr_area_title,
                                    #hbox(manual_add),
                                    scr_area,
                                    hbox(pb_update, pb_undo, spacer, pb_bound_delete, bound_field, pb_delete_unselected),
                                    )]
                Container: scr_area_title:
                    padding = Box(2, 2, 2, 2)
                    constraints = [vbox(
                                       hbox(del_lb, z, name, energy, inten, norm, cs_name, spacer),
                                       )
                                   ]
                    Label: del_lb:
                        text = '{:>4}'.format(' ')
                        #minimum_size = (20, 20)
                    PushButton: z:
                        text = 'Z'
                        minimum_size = (26, 20)
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='z')
                            param_model.update_name_list()
                    PushButton: name:
                        text = 'Names'
                        minimum_size = (80, 20)
                        maximum_size = 70
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='name')
                            param_model.update_name_list()
                    PushButton: energy:
                        text = 'Energy'
                        maximum_size = 70
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='energy')
                            param_model.update_name_list()
                    PushButton: inten:
                        text = 'Peak Int'
                        minimum_size = (90, 20)
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='maxv')
                            param_model.update_name_list()
                    Label: norm:
                        text = 'Rel Int(%)'
                        minimum_size = (60, 20)
                        #background = 'white'
                        align = 'center'
                    Label: cs_name:
                        text = 'CS'
                        tool_tip = 'Cross Section [barns/atom]'
                        minimum_size = (20, 20)
                    #PushButton: select_all:
                    #    text = 'Show All'
                    #    #maximum_size = 30
                    #    minimum_size = (30, 20)
                    #    checkable = True
                    #    clicked ::
                    #        if checked:
                    #            param_model.EC.turn_on_all()
                    #            param_model.data_for_plot()
                    #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                    #                                                param_model.total_l, param_model.total_m,
                    #                                                param_model.total_pileup)
                    #            plot_model.show_autofit_opt = True
                    #            plot_model._fig.canvas.draw()
                    #            select_all.text = 'Hide All'
                    #        else:
                    #            param_model.EC.turn_on_all(option=False)
                    #            param_model.data_for_plot()
                    #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                    #                                                param_model.total_l, param_model.total_m,
                    #                                                param_model.total_pileup)
                    #            plot_model.show_autofit_opt = False
                    #            plot_model._fig.canvas.draw()
                    #            select_all.text = 'Show All'

                ScrollArea: scr_area:
                    constraints = [height <= 230]

                    Form:
                        row_spacing = -1
                        #padding = Box(0, 0, 0, 0)
                        Looper:
                            iterable << list(param_model.result_dict_names)

                            PushButton: delete_btn:
                                text = 'Del'
                                maximum_size = 30
                                clicked ::
                                    param_model.EC.delete_item(loop_item)
                                    #apply_to_fit(param_model, plot_model, fit_model)
                                    param_model.EC.update_peak_ratio()
                                    param_model.data_for_plot()

                                    plot_model.plot_fit(param_model.prefit_x,
                                                        param_model.total_y,
                                                        param_model.auto_fit_all)
                                    # For plotting purposes, otherwise plot will not update
                                    plot_model.show_fit_opt = False
                                    plot_model.show_fit_opt = True
                                    param_model.update_name_list()
                                    #apply_to_fit(param_model, plot_model, fit_model, setting_model)

                            Container:
                                padding = Box(2, 2, 2, 2)
                                constraints = [hbox(delete_btn, lb_z, lb_name, lb_energy, lb_inten,
                                                    lb_norm, lb_cs, select_cb, spacer),
                                                    lb_norm.height==select_cb.height]

                                Label: lb_z:
                                    text << param_model.EC.element_dict[loop_item].z
                                    minimum_size = (30, 20)
                                    #background = 'white'
                                Label: lb_name:
                                    text << loop_item
                                    minimum_size = (80, 20)
                                    #background = 'white'
                                Label: lb_energy:
                                    text << str(param_model.EC.element_dict[loop_item].energy)
                                    minimum_size = (60, 20)
                                    #maximum_size = 80
                                    #background = 'white'
                                FloatField: lb_inten:
                                    value := param_model.EC.element_dict[loop_item].maxv
                                    minimum_size = (60, 20)
                                    maximum_size = 80
                                    background = 'white'
                                    #align = 'right'
                                    minimum = 0.00001
                                    submit_triggers = ['return_pressed']
                                    value ::
                                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

                                Label: lb_norm:
                                    text << set_low_bound(np.around(param_model.EC.element_dict[loop_item].norm, 2))
                                    minimum_size = (60, 20)
                                    #background = 'white'
                                    align = 'center'
                                Label: lb_cs:
                                    text = str(get_cs(loop_item, fit_model.param_dict['coherent_sct_energy']['value']))
                                    minimum_size = (40, 20)
                                CheckBox: select_cb:
                                    checkable = True
                                    minimum_size = (20, 20)
                                    checked := param_model.EC.element_dict[loop_item].status
                                    clicked ::
                                        param_model.EC.element_dict[loop_item].status = checked
                                        param_model.EC.element_dict[loop_item].stat_copy = param_model.EC.element_dict[loop_item].status
                                        #param_model.EC.update_peak_ratio()
                                        #param_model.update_name_list()
                                        param_model.data_for_plot()

                                        plot_model.plot_fit(param_model.prefit_x,
                                                            param_model.total_y,
                                                            param_model.auto_fit_all)
                                        # For plotting purposes, otherwise plot will not update
                                        plot_model.show_fit_opt = False
                                        plot_model.show_fit_opt = True

                PushButton: pb_bound_delete:
                    text = 'Delete Rel Int[%] < '
                    maximum_size = 350
                    visible = True
                    clicked ::
                        param_model.EC.delete_value_given_threshold(threshv=param_model.bound_val)
                        param_model.update_name_list()
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)
                        #param_model.data_for_plot()
                        #plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y, param_model.total_y_l)
                        #plot_model._fig.canvas.draw()
                FloatField: bound_field:
                    value := param_model.bound_val
                    maximum_size = 40
                    minimum = 0.00001
                PushButton: pb_delete_unselected:
                    text = 'Delete not selected items'
                    maximum_size = 350
                    visible = True
                    clicked ::
                        param_model.EC.delete_unselected_items()
                        param_model.update_name_list()
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

                        #param_model.data_for_plot()

                        #plot_model.plot_fit(param_model.prefit_x,
                        #                    param_model.total_y,
                        #                    param_model.auto_fit_all)
                        # For plotting purposes, otherwise plot will not update
                        #plot_model.show_fit_opt = False
                        #plot_model.show_fit_opt = True

                #PushButton: pb_bound:
                #    text = 'Do not plot lines < 0.1%'
                #    maximum_size = 350
                #    visible = True
                #    checkable = True
                #    clicked ::
                #        if checked:
                #            for k,v in six.iteritems(param_model.EC.element_dict):
                #                v.status = v.lbd_stat
                #            param_model.data_for_plot()
                #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y, param_model.total_y_l)
                #            plot_model._fig.canvas.draw()
                #            pb_bound.text = 'Plot lines < 0.1%'
                #        else:
                #            for k,v in six.iteritems(param_model.EC.element_dict):
                #                v.status = v.stat_copy
                #            param_model.data_for_plot()
                #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                #                                       param_model.total_y_l, param_model.total_y_m)
                #            plot_model._fig.canvas.draw()
                #            pb_bound.text = 'Do not plot lines < 0.1%'

                PushButton: pb_update:
                    text = 'Update'
                    clicked ::
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)
                PushButton: pb_undo:
                    text = 'Undo'
                    clicked ::
                        ### This part is similar as importing parameters from file
                        fit_model.default_parameters = fit_model.param_q[0]
                        fit_model.apply_default_param()

                        # update experimental plots
                        plot_model.parameters = fit_model.default_parameters
                        plot_model.plot_experiment()
                        plot_model.plot_exp_opt = False
                        plot_model.plot_exp_opt = True

                        # update autofit param
                        param_model.update_new_param(fit_model.default_parameters)
                        #param_model.get_new_param_from_file(parameter_file_path)
                        param_model.update_name_list()
                        param_model.EC.turn_on_all()

                        # update params for roi sum
                        setting_model.update_parameter(fit_model.default_parameters)

                        # calculate profile and plot
                        fit_model.get_profile()

                        # update experimental plot with new calibration values
                        plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                            fit_model.cal_spectrum,
                                            fit_model.residual)
                        # For plotting purposes, otherwise plot will not update
                        plot_model.show_fit_opt = False
                        plot_model.show_fit_opt = True

        GroupBox: fit_control:
            title = 'Fit summed spectrum.'
            #padding = Box(2, 2, 2, 2)
            constraints = [
                vbox(
                    gb_advanced,
                    hbox(lbl1, cb1, lbl2, cb2, spacer, pb_save_sum_fit),
                    hbox(pb_fit, gb_result),
                    #gb_result,
                ),
                lbl1.height == cb1.height == lbl2.height,
                lbl2.height == cb2.height,
            ]
            Label: lbl1:
                text = 'Step 1'
            ComboBox: cb1:
                items = [''] + fit_strategy_list
                index = 0
                index := fit_model.fit_strategy1
            Label: lbl2:
                text = 'Step 2'
            ComboBox: cb2:
                items = [''] + fit_strategy_list
                index = 0
                index := fit_model.fit_strategy2
            #Label: lbl3:
            #    text = 'Step 3'
            #ComboBox: cb3:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy3
            #Label: lbl4:
            #    text = 'Step 4'
            #ComboBox: cb4:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy4
            #Label: lbl5:
            #    text = 'Step 5'
            #ComboBox: cb5:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy5

            PushButton: pb_fit:
                text = 'Spectrum Fitting'
                clicked ::

                    if param_model.x0 is not None and param_model.y0 is not None:

                        # update parameter for fit
                        param_model.create_full_param()
                        fit_model.update_default_param(param_model.param_new)
                        fit_model.apply_default_param()

                        #fit_information.text = 'Fitting of summed spectrum starts.'
                        fit_model.fit_multiple()
                        #fit_information.text = 'Fitting of summed spectrum is done!'

                        # BUG: line color for pileup is not correct from fit
                        fit_model.get_profile()

                        # update experimental plot with new calibration values
                        plot_model.parameters = fit_model.param_dict
                        plot_model.plot_experiment()

                        #pb_plot.enabled = True
                        #plot_model.fit_x = fit_model.fit_x
                        #plot_model.fit_y = fit_model.fit_y
                        # BUG!!!
                        #plot_model.fit_all = fit_model.comps
                        #plot_model.fit_all = fit_model.cal_spectrum
                        #plot_model.residual = fit_model.residual
                        #plot_model.plot_fit()

                        plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                            fit_model.cal_spectrum,
                                            fit_model.residual)

                        # For plotting purposes, otherwise plot will not update
                        plot_model.show_fit_opt = False
                        plot_model.show_fit_opt = True

                        # update autofit param
                        param_model.update_new_param(fit_model.param_dict)
                        #param_model.get_new_param_from_file(parameter_file_path)
                        param_model.update_name_list()
                        param_model.EC.turn_on_all()

                        # update params for roi sum
                        setting_model.update_parameter(fit_model.param_dict)

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or processing parameters are not specified', btns)

            PushButton: pb_save_sum_fit:
                text = 'Save Spectrum/Fit'
                clicked ::
                    fit_model.output_summed_data_fit()
            #Label: fit_information:
            #    text := fit_model.fit_info
            #    foreground = 'red'

            Container: gb_advanced:
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(
                                    hbox(general_set_btn,
                                         element_btn, param_btn, spacer)
                                    )]

                PushButton: element_btn:
                    text = 'Edit Elements'
                    enabled = True
                    checkable = True
                    checked := element_edit.visible
                    clicked ::
                        if checked:
                            element_edit.show()
                        else:
                            element_edit.hide()

                PushButton: param_btn:
                    text = 'Edit Global Fitting Parameters'
                    enabled = True
                    checkable = True
                    checked := parameter_edit.visible
                    clicked ::
                        if checked:
                            parameter_edit.show()
                        else:
                            parameter_edit.hide()

                PushButton: general_set_btn:
                    text = 'General Settings'
                    enabled = True
                    checkable = True
                    checked := othersetting_edit.visible
                    clicked ::
                        if checked:
                            othersetting_edit.show()
                        else:
                            othersetting_edit.hide()

            Container: gb_result:
                #title = 'Fitting Statistics'
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(hbox(lbl_number, lbl_number_v,
                                         lbl_var_number, lbl_var_number_v,
                                         lbl_r2, lbl_r2_v, spacer),
                                    )]
                Label: lbl_number:
                    text = '# of iterations'
                    minimum_size = (60, 16)
                Label: lbl_number_v:
                    text << str(fit_model.function_num)
                    minimum_size = (60, 16)
                Label: lbl_var_number:
                    text = '# of variables'
                    minimum_size = (60, 16)
                Label: lbl_var_number_v:
                    text << str(fit_model.nvar)
                    minimum_size = (60, 16)
                #Label: lbl_chi:
                #    text = 'chi-square'
                #    minimum_size = (60, 16)
                #Label: lbl_chi_v:
                #    text << str(fit_model.chi2)
                #    minimum_size = (60, 16)
                Label: lbl_r2:
                    text = 'R-squared'
                    minimum_size = (60, 16)
                Label: lbl_r2_v:
                    text << str(fit_model.r2)
                    minimum_size = (60, 16)

        GroupBox: gb_fit_pixel:
            title = 'Fit spectrum of all individual pixels.'
            padding = Box(2, 2, 2, 2)
            constraints = [vbox(hbox(save_cb, lb1, fd1v, fd1h, lb2, fd2v, fd2h, spacer, interp_cb),
                                hbox(fit_pixel, spacer, to_db, output_btn, to_tiff, to_txt))]
            CheckBox: save_cb:
                text = 'Save plots'
                clicked ::
                    if checked:
                        fit_model.save_point = True
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
                    else:
                        fit_model.save_point = False
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
            Label: lb1:
                text = 'Start Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd1v:
                value := fit_model.point1v
                maximum_size = 40
                enabled = False
            IntField: fd1h:
                value := fit_model.point1h
                maximum_size = 40
                enabled = False
            Label: lb2:
                text = 'End Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd2v:
                value := fit_model.point2v
                maximum_size = 40
                enabled = False
            IntField: fd2h:
                value := fit_model.point2h
                maximum_size = 40
                enabled = False

            CheckBox: interp_cb:
                text = 'Interpolation with x,y'
                checked := fit_model.map_interpolation

            PushButton: fit_pixel:
                text = 'Individual Pixel Fitting'
                clicked ::

                    if param_model.x0 is not None and param_model.y0 is not None:

                        fit_model.fit_single_pixel()
                        # add scalers to fit dict
                        scaler_key = [v for v in six.iterkeys(img_model_adv.data_dict) if 'scaler' in v]
                        if len(scaler_key) > 0:
                            fit_model.fit_img[list(fit_model.fit_img.keys())[0]].update(img_model_adv.data_dict[scaler_key[0]])

                        img_model_adv.data_dict.update(fit_model.fit_img)
                        img_model_rgb.data_dict.update(fit_model.fit_img)
                        img_model_adv.set_default_dict(img_model_adv.data_dict)

                        # visualization purpose
                        img_model_adv.data_dict_keys = []
                        img_model_adv.data_dict_keys = list(img_model_adv.data_dict.keys())
                        img_model_rgb.data_dict_keys = []
                        img_model_rgb.data_dict_keys = list(img_model_rgb.data_dict.keys())

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or processing parameters are not specified', btns)

            #Label: pixel_fit_information:
            #    text := fit_model.pixel_fit_info
            #    foreground = 'red'

            PushButton: to_db:
                text = 'Save to database'
                enabled = databroker is not None
                #minimum_size = (20, 20)
                clicked ::
                    fit_model.save_pixel_fitting_to_db()

            PushButton: output_btn:
                text = 'Output setup'
                enabled = True
                checkable = True
                checked := output_edit.visible
                clicked ::
                    if checked:
                        output_edit.show()
                    else:
                        output_edit.hide()

            PushButton: to_tiff:
                text = 'Save to tiff'
                #minimum_size = (20, 20)
                clicked ::
                    fit_model.output_2Dimage()
            PushButton: to_txt:
                text = 'Save to txt'
                #minimum_size = (20, 20)
                clicked ::
                    fit_model.output_2Dimage(to_tiff=False)


enamldef OutputSetup(Window): output_win:
    attr fit_model

    Container:
        constraints = [vbox(gb_range, save_btn),]

        #GroupBox: gb_norm:
        #    constraints = [vbox(lbl_norm, cmb_scaler),]
        #    Label: lbl_norm:
        #        text = 'Output data with normalization'
        #    ComboBox: cmb_scaler:
        #        items << ['Normalized by'] + fit_model.scaler_keys
        #        index >> fit_model.scaler_index
        #        index = 0

        GroupBox: gb_range:
            constraints = [vbox(cb1, hbox(lbl_low, ff_low),
                                hbox(lbl_high, ff_high),)]
            CheckBox: cb1:
                text = 'Calculate ROI sum within given range (KeV)'
                checked := fit_model.roi_sum_opt['status']
            Label: lbl_low:
                text = 'low range'
            FloatField: ff_low:
                value := fit_model.roi_sum_opt['low']
            Label: lbl_high:
                text = 'high range'
            FloatField: ff_high:
                value := fit_model.roi_sum_opt['high']
        PushButton: save_btn:
            text = 'Save'
            clicked ::
                fit_model.calculate_roi_sum()
                output_win.close()


enamldef AutoFindElements(Window): auto_win:
    attr parameter_model
    attr plot_model
    title = 'Automatic Element Finding'
    destroy_on_close = False

    Container:
        #padding = Box(2, 2, 2, 2)
        constraints = [
            vbox(
                hbox(param_form),
                hbox(find_btn, spacer),
            ),
        ]
        #title = 'Or use automatic element finding to get elements.'
        #ScrollArea: top_cntr:
        #constraints = [height <= 80]
        Form: param_form:
            row_spacing = -1
            Looper:
                #iterable << sorted([v for k,v in six.iteritems(param_model.param_new) if v.get('description')],
                #                   key=lambda x: x['description'])
                iterable << autofit_param
                Label:
                    text = param_model.param_new[loop_item]['description']
                    #tool_tip = loop_item['tool_tip']
                    maximum_size = 140
                Container:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff, pb_value_default)]
                    FloatField: ff:
                        value := param_model.param_new[loop_item]['value']
                        value ::
                            if loop_item == 'coherent_sct_energy':
                                v = round((value + 0.8)*100.0)/100.0  # Add 0.8 to float in a reliable way
                                plot_model.incident_energy = value  # Just copy the selected value of incident energy
                                param_model.param_new['non_fitting_values']['energy_bound_high']['value'] = v
                                param_model.energy_bound_high_buf = v
                        maximum_size = 160
                    PushButton: pb_value_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff.value = param_model.param_new[loop_item]['default']

            Looper: 
                iterable << [param_model.param_new['non_fitting_values'][k] for k in ('energy_bound_high',)]
                Label:
                    text = loop_item['description']
                    maximum_size = 140
                Container: cont:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff_bound_high, pb_bd_default)]
                    FloatField: ff_bound_high:
                        value := param_model.energy_bound_high_buf
                        maximum_size = 100
                    PushButton: pb_bd_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff_bound_high.value = loop_item['default_value']

            Looper: 
                iterable << [param_model.param_new['non_fitting_values'][k] for k in ('energy_bound_low',)]
                Label:
                    text = loop_item['description']
                    maximum_size = 140
                Container:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff_bound_low, pb_bd_default)]
                    FloatField: ff_bound_low:
                        value := param_model.energy_bound_low_buf
                        maximum_size = 100
                    PushButton: pb_bd_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff_bound_low.value = loop_item['default_value']


        PushButton: find_btn:
            text = 'Find Elements'
            enabled = True
            clicked ::
                param_model.find_peak()
                param_model.EC.order()
                param_model.update_name_list()

                param_model.EC.turn_on_all()
                param_model.data_for_plot()

                # update experimental plots in case the coefficients change
                plot_model.parameters = param_model.param_new
                plot_model.plot_experiment()

                plot_model.plot_fit(param_model.prefit_x,
                                    param_model.total_y,
                                    param_model.auto_fit_all)

                # For plotting purposes, otherwise plot will not update
                plot_model.show_fit_opt = False
                plot_model.show_fit_opt = True
                auto_win.close()


def sorted_param(param_model):
    return list(([v for k,v in six.iteritems(param_model.param_new['non_fitting_values']) if k in ["energy_bound_low", "energy_bound_high"] ]))


enamldef ElementEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model
    Container:
        constraints = [vbox(hbox(cal_pbn, spacer),
                            cmb_element,
                            hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        padding = Box(5, 5, 5, 5)

        PushButton: cal_pbn:
            text = 'Update & Plot'
            clicked ::
                calculate_spectrum_helper(fit_model, plot_model,
                                          param_model, setting_model)

        ComboBox: cmb_element:
            items << ['Select Element'] + fit_model.element_list
            index = 0
            index := fit_model.selected_index
            #selected_item >> fit_model.selected_element
        Label: lbl1:
            text = '{:>20} {:>20} {:>26} {:>26} {:>26} {:>16}'.format('name','energy', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]

        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper:
                    #iterable << sorted([k for k in six.iterkeys(fit_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    #iterable << list(sorted([v for v in six.iterkeys(fit_model.param_dict) if cmb_element.selected_item.split('_')[0] in str(v)]))
                    iterable << fit_model.elementinfo_list

                    Label: name_lbl:
                        text << loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        constraints = [hbox(
                            energy_v, ff_value, ff_min, ff_max,
                            cb_strat0, cb_strat1, cb_strat2,
                            cb_strat3, cb_strat4, cb_strat5, cb_strat6, spacer)
                        ]
                        Label: energy_v:
                            text = get_energy(loop_item)
                            minimum_size = (50, 20)
                        FloatField: ff_value:
                            value := fit_model.param_dict[loop_item]['value']
                            #minimum = fit_model.param_dict[loop_item]['min']
                            #maximum = fit_model.param_dict[loop_item]['max']
                        FloatField: ff_min:
                            value := fit_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := fit_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.selected_item  #items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef ParameterEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model

    destroy_on_close = False
    Container:
        constraints = [vbox(hbox(cal_pbn, spacer),
                            hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        #padding = Box(5, 5, 5, 5)
        PushButton: cal_pbn:
            text = 'Update & Plot'
            clicked ::
                calculate_spectrum_helper(fit_model, plot_model,
                                          param_model, setting_model)
        Label: lbl1:
            #text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
            text = '{:>16} {:>42} {:>32} {:>32} {:>16}'.format('name', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]
        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper:
                    #iterable << sorted([k for k in six.iterkeys(fit_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    iterable << fit_model.global_param_list
                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [hbox(ff_value, ff_min, ff_max, cb_strat0, cb_strat1, cb_strat2, cb_strat3,
                                            cb_strat4, cb_strat5, cb_strat6,spacer)]
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        FloatField: ff_value:
                            value := fit_model.param_dict[loop_item]['value']
                            minimum_size = (150, 20)
                        FloatField: ff_min:
                            value := fit_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := fit_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef OtherSettingEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model

    Container :
        DockArea :
            layout = TabLayout('item_bkg', 'item_controller', 'item_controller_pixel')
            DockItem:
                closable = False
                name = 'item_bkg'
                title = 'Background/Escape'
                Container:
                    Form:
                        Label:
                            text = 'Background width'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['background_width']
                        Label:
                            text = 'Escape peak'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['escape_ratio']
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                calculate_spectrum_helper(fit_model, plot_model,
                                                          param_model, setting_model)
                        Label:
                            pass

            DockItem:
                closable = False
                name = 'item_controller'
                title = 'Fitting Controller for Summed Spectrum'
                Container:
                    Form:
                        Label:
                            text = 'Max iteration number'
                        IntField:
                            value := fit_model.fit_num
                        Label:
                            text = 'Convergence criterion'
                        FloatField:
                            value := fit_model.ftol
                        Label:
                            text = 'Lower bound'
                        FloatField:
                            value := param_model.energy_bound_low_buf
                            # value := fit_model.param_dict['non_fitting_values']['energy_bound_low']['value']
                        Label:
                            text = 'Higher bound'
                        FloatField:
                            value := param_model.energy_bound_high_buf
                            # value := fit_model.param_dict['non_fitting_values']['energy_bound_high']['value']
                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                calculate_spectrum_helper(fit_model, plot_model,
                                                          param_model, setting_model)
                        Label:
                            pass

            DockItem:
                closable = False
                name = 'item_controller_pixel'
                title = 'Fitting Controller for Single Pixels'
                Container:
                    Form:
                        Label:
                            text = 'Select fitting algorithm'
                        ComboBox: cb_algorithm:
                            items = ['non-negative leastsq', 'nonlinear leastsq']
                            index := fit_model.pixel_fit_method
                            #index ::
                            #    if index == 0:
                            #        fit_model.pixel_fit_method = 0
                            #    if index == 1:
                            #        fit_model.pixel_bin = 4
                        #Label:
                        #    text = 'Max iteration number'
                        #IntField:
                        #    value := fit_model.fit_num
                        #Label:
                        #    text = 'Convergence criterion'
                        #FloatField:
                        #    value := fit_model.ftol
                        Label:
                            text = 'Add const to background'
                        FloatField:
                            value := fit_model.raise_bg
                        Label:
                            text = 'Bin data on x,y positions'
                        ComboBox: cb_bin:
                            items = ['0', '2 by 2', '3 by 3']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.pixel_bin = 0
                                if index == 1:
                                    fit_model.pixel_bin = 4
                                if index == 2:
                                    fit_model.pixel_bin = 9
                        Label:
                            text = 'Use linear background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 1
                            index ::
                                if index == 0:
                                    fit_model.linear_bg = True
                                else:
                                    fit_model.linear_bg = False
                        Label:
                            text = 'Use snip method for background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.use_snip = True
                                else:
                                    fit_model.use_snip = False
                        Label:
                            text = 'Bin data on energy axis'
                        ComboBox:
                            items = ['0', '2', '3']
                            index = 0
                            index ::
                                fit_model.bin_energy = int(selected_item)

                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                pass
                        Label:
                            pass

            #DockItem:
            #    closable = False
            #    name = 'pileup'
            #    title = 'Pileup Peak'
            #    Container:
            #        Form:
            #            Label: e1:
            #                text = 'Element1, i.e. Si_Ka1'
            #            Field: fd1:
            #                text = ''
            #            Label: e2:
            #                text = 'Element2, i.e. Fe_Ka1'
            #            Field: fd2:
            #                text = ''
            #            #Label: intensity:
            #            #    text = 'Peak Int'
            #            #FloatField: intensity_ff:
            #            #    pass
            #            PushButton: add_btn:
            #                text = 'Apply'
            #                clicked ::
            #                    fit_model.pileup_data['element1'] = fd1.text
            #                    fit_model.pileup_data['element2'] = fd2.text
            #                    #fit_model.pileup_data['intensity'] = intensity_ff.value
            #                    fit_model.add_pileup()
            #                    fit_model.update_name_list()
            #                    calculate_spectrum_helper(fit_model, plot_model, param_model)
            #            Label:
            #                pass


def save_defaults(parameter_model):
    user_path = os.path.join(os.path.expanduser('~'), '.pyxrf',
                             'xrf_parameter_user.json')
    # format the dictionary
    dct = format_dict(parameter_model.parameters, parameter_model.element_list)
    json_out = json.dumps(dct)
    with open(user_path, 'w') as out_file:
        out_file.write(json_out)


enamldef EditPileupPeak(Window): pileup_win:
    attr param_model
    attr plot_model
    destroy_on_close = False

    #title = 'Pileup Peak Editor'
    Container:
        Form:
            Label: e1:
                text = 'Element1, i.e. Si_Ka1'
            Field: fd1:
                text = ''
            Label: e2:
                text = 'Element2, i.e. Fe_Ka1'
            Field: fd2:
                text = ''
            Label: intensity:
                text = 'Peak Int'
            FloatField: intensity_ff:
                pass
            PushButton: add_btn:
                text = 'Add'
                maximum_size = 60
                clicked ::
                    param_model.pileup_data['element1'] = fd1.text
                    param_model.pileup_data['element2'] = fd2.text
                    param_model.pileup_data['intensity'] = intensity_ff.value

                    param_model.add_pileup()
                    param_model.EC.update_peak_ratio()
                    param_model.update_name_list()
                    param_model.data_for_plot()

                    plot_model.plot_fit(param_model.prefit_x,
                                        param_model.total_y,
                                        param_model.auto_fit_all)
                    # For plotting purposes, otherwise plot will not update
                    plot_model.show_fit_opt = False
                    plot_model.show_fit_opt = True
                    pileup_win.close()


def set_low_bound(value, thresh_v=0.1):
    """
    Return values only above given threshold.

    Parameters
    ----------
    value : float
    thresh_v : float, opt
        threshold value
    """
    if value <= thresh_v:
        return '< {}'.format(thresh_v)
    else:
        return str(value)


def calculate_spectrum_helper(fit_model, plot_model,
                              param_model, setting_model):
    """
    Calculate spectrum, and update plotting and param_model.
    """
    if fit_model.x0 is None or fit_model.y0 is None:
        return

    fit_model.get_profile()

    # update experimental plot with new calibration values
    plot_model.parameters = fit_model.param_dict
    plot_model.plot_experiment()

    plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                        fit_model.cal_spectrum,
                        fit_model.residual)

    # For plotting purposes, otherwise plot will not update
    plot_model.show_fit_opt = False
    plot_model.show_fit_opt = True

    # update autofit param
    param_model.update_new_param(fit_model.param_dict)
    #param_model.get_new_param_from_file(parameter_file_path)
    param_model.update_name_list()
    param_model.EC.turn_on_all()

    # update params for roi sum
    setting_model.update_parameter(fit_model.param_dict)


def apply_to_fit(param_model, plot_model,
                 fit_model, setting_model):
    """
    Update plot, and apply updated parameters to fitting process.
    """
    #param_model.update_name_list()
    param_model.EC.update_peak_ratio()
    param_model.data_for_plot()

    # update experimental plots in case the coefficients change
    plot_model.parameters = param_model.param_new
    plot_model.plot_experiment()

    plot_model.plot_fit(param_model.prefit_x,
                        param_model.total_y,
                        param_model.auto_fit_all)

    # For plotting purposes, otherwise plot will not update
    plot_model.show_fit_opt = False
    plot_model.show_fit_opt = True

    # update parameter for fit
    param_model.create_full_param()
    fit_model.update_default_param(param_model.param_new)
    fit_model.apply_default_param()

    # update params for roi sum
    setting_model.update_parameter(fit_model.param_dict)


def get_energy(name):
    """
    Calculate emission line for given element name.
    """
    if 'pileup' in name or 'user' in name.lower():  # for pileup peak
        return '-'
    name_list = name.split('_')
    e = Element(name_list[0])
    return str(np.around(e.emission_line[name_list[1]], decimals=4))
