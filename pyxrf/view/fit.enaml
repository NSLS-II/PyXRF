from __future__ import absolute_import
import numpy as np
import math
import copy
import os
import six

from enaml.widgets.api import (Container, PushButton, Label,
                               Form, Field, MultilineField, FileDialogEx, DockItem,
                               DockArea, CheckBox, ComboBox,
                               ScrollArea, Window, GroupBox, RadioButton,
                               MainWindow, Dialog)

from enaml.widgets.api import RadioButton as DefaultRadioButton

from enaml.layout.api import hbox, vbox, HSplitLayout, VSplitLayout, TabLayout, spacer, align
from enaml.stdlib.fields import FloatField
from enaml.layout.geometry import Box
from enaml.core.api import Include, Looper

from enaml.stdlib.fields import FloatField as DefaultFloatField
from enaml.stdlib.fields import IntField as DefaultIntField

from enaml.stdlib.dialog_buttons import DialogButton
from enaml.stdlib.message_box import critical, question

from ..model.guessparam import fit_strategy_list, save_as, bound_options, autofit_param
from ..model.fit_spectrum import get_cs
from ..model.fileio import sep_v

from skbeam.core.fitting.xrf_model import (K_LINE, L_LINE, M_LINE)
from skbeam.fluorescence import XrfElement as Element

import logging
logger = logging.getLogger()

try:
    import databroker
except ImportError:
    databroker = None


# userpeak_list = ['Userpeak'+str(i) for i in range(1, 11)]  # 10 users peak

enamldef FloatField(DefaultFloatField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef IntField(DefaultIntField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef RadioButton(DefaultRadioButton):
    minimum_size = (80, 20)

enamldef LabelTitle(Label):
    maximum_size = 80
    align = 'left'

#bound_options = ['none', 'lohi', 'fixed', 'lo', 'hi']

enamldef FitView(DockItem): fit_view:
    attr plot_model
    attr param_model
    attr fit_model
    attr element_edit
    attr parameter_edit
    attr othersetting_edit
    attr autofind_edit
    attr select_standard_edit
    attr save_quant_calibration_edit
    attr img_model_adv
    attr img_model_rgb
    attr pileup_edit
    attr setting_model
    attr output_edit

    Container:
        padding = Box(2, 2, 2, 2)
        constraints = [
            vbox(
                #hbox(new_param_load, reload_btn, lbl_param, spacer),
                #hbox(lbl_param, spacer),
                load_gb,
                #hbox(auto_find_gb),
                control_element,
                fit_control,
                gb_fit_pixel,
                #hbox(fit_pixel, spacer),
            ),
        ]

        GroupBox: load_gb:
            padding = Box(2, 2, 2, 2)
            constraints = [vbox(
                                hbox(lbl_load, spacer),
                                hbox(new_param_load, saveas_btn, lbl_param, spacer),
                                hbox(pb_auto, pb_select_standard, lbl_standard, spacer),)
                           ]
            Label: lbl_load:
                text = 'Load elemental parameters from file.'
            PushButton: new_param_load:
                text = 'Import Parameters'
                #maximum_size = 200
                clicked ::

                    if fit_model.data is not None:

                        parameter_file_path = FileDialogEx.get_open_file_name(fit_view)
                        if parameter_file_path:

                            # update parameter for fit
                            try:
                                fit_model.read_param_from_file(parameter_file_path)
                            except Exception as ex:
                                print(f"Error occurred while reading parameter file: {ex}")

                                btns = [DialogButton('Ok', 'accept')]
                                critical(self, 'ERROR',
                                         "Error occurred while reading the parameter file:\n"\
                                         f"'{parameter_file_path}'", btns)

                            else:
                                # Make a decision, if the incident energy from metadata should be replaced
                                #   with the incident energy from the parameter file
                                overwrite_metadata_incident_energy = False

                                # Incident energy from the parameter file
                                param_incident_energy = fit_model.default_parameters['coherent_sct_energy']['value']

                                if io_model.incident_energy_available:

                                    # Incident energy from datafile metadata
                                    mdata_incident_energy = io_model.scan_metadata.get_mono_incident_energy()

                                    # If two energies have very close values (say 1 eV), then the difference doesn't matter
                                    #   Consider two energies equal (they probably ARE equal) and use the value
                                    #   from datafile metadata.
                                    if not math.isclose(param_incident_energy, mdata_incident_energy, abs_tol=0.001):

                                        msg = f"The values of incident energy from data file metadata and parameter file are different.\n"\
                                              f"  Incident energy from metadata: {mdata_incident_energy} keV.\n"\
                                              f"  Incident energy from the loaded parameter file: {param_incident_energy} keV.\n"\
                                              f"Would you prefer to use the incident energy from the parameter file for processing?"

                                        btn_pressed = question(self, 'Question Dialog', msg)
                                        if btn_pressed and (btn_pressed.text.lower() == "yes"):
                                            overwrite_metadata_incident_energy = True

                                if overwrite_metadata_incident_energy:
                                    print(f"Using incident energy from the parameter file: {param_incident_energy} keV")
                                else:
                                    # Keep the incident energy from the file
                                    print(f"Using incident energy from the datafile metadata: "
                                          f"{mdata_incident_energy} keV")
                                    fit_model.default_parameters["coherent_sct_energy"]["value"] = round(mdata_incident_energy, 6)

                                fit_model.apply_default_param()

                                # update experimental plots
                                plot_model.parameters = fit_model.default_parameters
                                plot_model.plot_experiment()
                                plot_model.plot_exp_opt = False
                                plot_model.plot_exp_opt = True

                                # update autofit param
                                param_model.update_new_param(fit_model.default_parameters)
                                #param_model.get_new_param_from_file(parameter_file_path)

                                param_model.EC.order()
                                param_model.update_name_list()
                                param_model.EC.turn_on_all()
                                param_model.data_for_plot()

                                # update params for roi sum
                                setting_model.update_parameter(fit_model.default_parameters)

                                # update file name
                                lbl_param.text = 'Loaded file: {}'.format(parameter_file_path.split(sep_v)[-1])

                                # calculate profile and plot
                                fit_model.get_profile()

                                # update experimental plot with new calibration values
                                plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                                    fit_model.cal_spectrum,
                                                    fit_model.residual)

                                plot_model.plot_exp_opt = False
                                plot_model.plot_exp_opt = True
                                # For plotting purposes, otherwise plot will not update
                                plot_model.show_fit_opt = False
                                plot_model.show_fit_opt = True

                                # The following statement is necessary mostly to set the correct value of
                                #   the upper boundary of the energy range used for emission line search.
                                plot_model.change_incident_energy(fit_model.default_parameters["coherent_sct_energy"]["value"])

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded', btns)

            Label: lbl_param:
                text = 'No parameter is loaded.'

            PushButton: saveas_btn:
                text = 'Save'
                clicked ::
                    path = FileDialogEx.get_save_file_name(fit_view,
                                                           current_path=fit_model.result_folder)
                    if path:
                        save_as(path, fit_model.param_dict)

        #GroupBox: auto_find_gb:
        #    title = 'Or use automatic element finding.'
        #    padding = Box(2, 2, 2, 2)
        #    constraints = [hbox(pb_auto, spacer)]

            PushButton: pb_auto:
                text = 'Find Elements Automatically'
                enabled = True
                clicked ::
                    if fit_model.data is not None:
                        autofind_edit.show()
                    else:
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded', btns)

            PushButton: pb_select_standard:
                text = 'Load Standard'
                enabled = True
                clicked ::

                    if fit_model.data is None:
                        # The data is not loaded
                        btns = [DialogButton('Ok', 'accept')]
                        critical(self, 'ERROR', f'Experimental data is not loaded', btns)
                    else:

                        # Reload standards (some of them may change, reloading refreshes the copy)
                        fit_model.param_quant_estimation.clear_standards()
                        fit_model.param_quant_estimation.load_standards()
                        # Update the following fields will update the list of available standards
                        #   if the loaded files changed
                        fit_model.qe_param_built_in_ref = fit_model.param_quant_estimation.standards_built_in
                        fit_model.qe_param_custom_ref = fit_model.param_quant_estimation.standards_custom


                        # Another move, necessary to make the list in the dialog box working properly:
                        #   the selected standard must be 'checked' when the window opens
                        fit_model.qe_standard_selected_ref = None

                        # The current selection is set to the currently selected standard
                        #   held in 'fit_model.qe_standard_selected_copy'
                        fit_model.qe_standard_selected_ref = \
                            fit_model.param_quant_estimation.set_selected_standard(fit_model.qe_standard_selected_copy)

                        find_peaks = False
                        if select_standard_edit.exec_():
                            # Process the new selection
                            fit_model.param_quant_estimation.set_selected_standard(fit_model.qe_standard_selected_ref)
                            fit_model.qe_standard_selected_copy = copy.deepcopy(fit_model.qe_standard_selected_ref)
                            if fit_model.qe_standard_selected_ref is not None:
                                msg = f"Standard #{fit_model.qe_standard_selected_ref['serial']}"
                                if fit_model.param_quant_estimation.is_standard_custom(fit_model.qe_standard_selected_ref):
                                    msg += " (user-defined)"
                                lbl_standard.text = msg
                                find_peaks = True
                            else:
                                fit_model.param_quant_estimation.clear_standards()
                                fit_model.qe_standard_selected_ref = None
                                fit_model.qe_standard_selected_copy = None
                                lbl_standard.text = "No quantitative standard is loaded"
                        else:
                            # If standard selection is cancelled, but currently selected standard is not in the list
                            #   then clear selection completely. If the selected standard is present in the new
                            #   loaded set, then the selection remains unchanged
                            if not fit_model.param_quant_estimation.find_standard(fit_model.qe_standard_selected_copy):
                                fit_model.param_quant_estimation.clear_standards()
                                fit_model.qe_standard_selected_ref = None
                                fit_model.qe_standard_selected_copy = None
                                lbl_standard.text = "No quantitative standard is loaded"
                            # There is not need to find peaks, since the selection was not changed and
                            #   the dialog box could be opened by mistake

                        if find_peaks:

                            incident_energy = param_model.param_new['coherent_sct_energy']['value']
                            # Generate the data structure for the results of processing of standard data
                            fit_model.param_quant_estimation.gen_fluorescence_data_dict(incident_energy)
                            # Obtain the list (dictionary) of elemental lines from the generated structure
                            elemental_lines = fit_model.param_quant_estimation.fluorescence_data_dict["element_lines"]

                            param_model.find_peak(elemental_lines=elemental_lines.keys())
                            param_model.EC.order()
                            param_model.update_name_list()

                            param_model.EC.turn_on_all()
                            param_model.data_for_plot()

                            # update experimental plots in case the coefficients change
                            plot_model.parameters = param_model.param_new
                            plot_model.plot_experiment()

                            plot_model.plot_fit(param_model.prefit_x,
                                                param_model.total_y,
                                                param_model.auto_fit_all)

                            # Update displayed intensity of the selected peak
                            plot_model.compute_manual_peak_intensity()

                            # Show the summed spectrum used for fitting
                            plot_model.plot_exp_opt = False
                            plot_model.plot_exp_opt = True
                            # For plotting purposes, otherwise plot will not update
                            plot_model.show_fit_opt = False
                            plot_model.show_fit_opt = True

            Label: lbl_standard:
                text = 'No quantitative standard is loaded'

        GroupBox: control_element:
            title = 'Add/Remove elements (Userpeak with center energy at 5 keV can be added.).'
            padding = Box(2, 2, 2, 2)
            constraints = [
                vbox(
                    hbox(eline_selection, intensity_lb, intensity_fd,
                         manual_add, manual_remove, spacer, pb_pileup),
                    hbox(spacer, lb_userpeak_energy, fd_userpeak_energy, lb_userpeak_fwhm, fd_userpeak_fwhm, pb_userpeak_update),
                    pre_fit,
                ),
            ]
            Container: eline_selection:
                constraints = [
                    contents_left == btn_cb_prev.left,
                    btn_cb_prev.right+2 == btn_cb_next.left,
                    btn_cb_next.right+5 == cb_select.left,
                    cb_select.right == contents_right,
                ]

                PushButton: btn_cb_prev:
                    text = '<'
                    enabled << plot_model.allow_select_elines
                    maximum_size = (15, 24)
                    clicked ::
                        if cb_select.index > 1:
                            cb_select.index -= 1
                        cb_select.set_focus()  # Return focus to the combo box

                PushButton: btn_cb_next:
                    text = '>'
                    enabled << plot_model.allow_select_elines
                    maximum_size = (15, 24)
                    clicked ::
                        if cb_select.index < len(cb_select.items) - 1:
                            cb_select.index += 1
                        cb_select.set_focus()  # Return focus to the combo box

                ComboBox: cb_select:
                    #items = ['Select Lines'] +\
                    #        K_LINE + L_LINE + M_LINE + userpeak_list
                    items = ['Select Lines'] + param_model.get_user_peak_list(include_user_peaks=True)
                    index = 0
                    index := plot_model.element_id
                    enabled << plot_model.allow_select_elines
                    index ::
                        if cb_select.index > 0:
                            param_model.e_name = cb_select.selected_item
                            try:
                                if "Userpeak" in cb_select.selected_item:
                                    fit_model.select_index_by_eline_name(cb_select.selected_item)
                                    # Show the marker at the center of the userpeak
                                    plot_model.set_plot_vertical_marker(fit_model.add_userpeak_energy)
                            except Exception as ex:
                                # Show the marker at its current or default location
                                plot_model.set_plot_vertical_marker()
                                pass

            Label: intensity_lb:
                text = 'Peak Int'

            FloatField: intensity_fd:
                value := param_model.add_element_intensity
                maximum_size = 80
                enabled << (cb_select.index > 0) and plot_model.allow_add_eline_fit

            PushButton: manual_add:
                text = 'Add'
                enabled << (cb_select.index > 0) and plot_model.allow_add_eline_fit
                clicked ::
                    # Verify if we are adding a userpeak
                    is_userpeak = False
                    ename = plot_model.get_element_line_name_by_id(plot_model.element_id, include_user_peaks=True)
                    if ename and (ename.lower().startswith("userpeak")):
                        is_userpeak = True

                    # The following set of conditions is not complete, but sufficient
                    if param_model.x0 is None or param_model.y0 is None:
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or initial spectrum fitting is not performed', btns)

                    elif is_userpeak and (not plot_model.vertical_marker_is_visible):
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, '', f'Select position of userpeak by clicking at the plot', btns)

                    else:
                        try:
                            plot_model.add_peak_manual()
                            # ``apply_to_fit`` takes some time to execute, so do it only for the user defined peaks
                            #   After calling ``apply_to_fit``, the line parameters may be edited
                            #   For other lines, the button ``Update`` must be pressed first.
                            if "Userpeak" in cb_select.selected_item:
                                apply_to_fit(param_model, plot_model, fit_model, setting_model)

                        except Exception as ex:
                            btns = [DialogButton('Ok', 'accept')]
                            critical(self, 'ERROR', str(ex), btns)

                        try:
                            if "Userpeak" in cb_select.selected_item:
                                fit_model.select_index_by_eline_name(cb_select.selected_item)
                                param_model.data_for_plot()
                                plot_model.plot_fit(param_model.prefit_x,
                                                    param_model.total_y,
                                                    param_model.auto_fit_all)
                                fit_model.update_userpeak_controls()
                        except Exception as ex:
                            pass

                        cb_select.set_focus()  # Return focus to the combo box

            PushButton: manual_remove:
                text = 'Remove'
                enabled << (cb_select.index > 0) and plot_model.allow_remove_eline_fit
                clicked ::
                    plot_model.remove_peak_manual(param_model.e_name)
                    cb_select.set_focus()  # Return focus to the combo box
                    # Completely remove userpeaks from all dictionaries. This operation
                    #   takes considerable time, so do it only for userpeaks. For other
                    #   peaks, the button 'Update' needs to be pressed to completely
                    #   remove peaks (this is faster and enables 'Undo').
                    if "userpeak" in param_model.e_name.lower():
                        param_model.update_name_list()
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

            PushButton: pb_pileup:
                text = 'Add Pileup Peaks'
                clicked ::
                    # The following set of conditions is not complete, but sufficient
                    if param_model.x0 is not None and param_model.y0 is not None:
                        pileup_edit.show()
                    else:
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or initial spectrum fitting is not performed', btns)

            Label: lb_userpeak_energy:
                text = 'Energy'
                visible << "Userpeak" in cb_select.selected_item and plot_model.allow_remove_eline_fit

            FloatField: fd_userpeak_energy:
                maximum_size = 80
                visible << "Userpeak" in cb_select.selected_item and plot_model.allow_remove_eline_fit
                value := fit_model.add_userpeak_energy

            Label: lb_userpeak_fwhm:
                text = 'FWHM'
                visible << "Userpeak" in cb_select.selected_item and plot_model.allow_remove_eline_fit

            FloatField: fd_userpeak_fwhm:
                maximum_size = 80
                visible << "Userpeak" in cb_select.selected_item and plot_model.allow_remove_eline_fit
                value := fit_model.add_userpeak_fwhm

            PushButton: pb_userpeak_update:
                text = 'Update peak'
                visible << "Userpeak" in cb_select.selected_item and plot_model.allow_remove_eline_fit
                clicked ::
                    # Save peak maximum value
                    selected_eline = cb_select.selected_item
                    peak_value = param_model.EC.element_dict[selected_eline].maxv
                    fit_model.update_userpeak()

                    calculate_spectrum_helper(fit_model, plot_model,
                                              param_model, setting_model)

            GroupBox: pre_fit:
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(scr_area_title,
                                    #hbox(manual_add),
                                    scr_area,
                                    hbox(pb_update, pb_undo, spacer, pb_bound_delete, bound_field, pb_delete_unselected),
                                    )]
                Container: scr_area_title:
                    padding = Box(2, 2, 2, 2)
                    constraints = [vbox(
                                       hbox(del_lb, z, name, energy, inten, norm, cs_name, spacer),
                                       )
                                   ]
                    Label: del_lb:
                        text = '{:>4}'.format(' ')
                        #minimum_size = (20, 20)
                    PushButton: z:
                        text = 'Z'
                        minimum_size = (26, 20)
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='z')
                            param_model.update_name_list()
                    PushButton: name:
                        text = 'Names'
                        minimum_size = (80, 20)
                        maximum_size = 70
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='name')
                            param_model.update_name_list()
                    PushButton: energy:
                        text = 'Energy'
                        maximum_size = 70
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='energy')
                            param_model.update_name_list()
                    PushButton: inten:
                        text = 'Peak Int'
                        minimum_size = (90, 20)
                        #background = 'white'
                        clicked ::
                            param_model.EC.order(option='maxv')
                            param_model.update_name_list()
                    Label: norm:
                        text = 'Rel Int(%)'
                        minimum_size = (60, 20)
                        #background = 'white'
                        align = 'center'
                    Label: cs_name:
                        text = 'CS'
                        tool_tip = 'Cross Section [barns/atom]'
                        minimum_size = (20, 20)
                    #PushButton: select_all:
                    #    text = 'Show All'
                    #    #maximum_size = 30
                    #    minimum_size = (30, 20)
                    #    checkable = True
                    #    clicked ::
                    #        if checked:
                    #            param_model.EC.turn_on_all()
                    #            param_model.data_for_plot()
                    #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                    #                                                param_model.total_l, param_model.total_m,
                    #                                                param_model.total_pileup)
                    #            plot_model.show_autofit_opt = True
                    #            plot_model._fig.canvas.draw()
                    #            select_all.text = 'Hide All'
                    #        else:
                    #            param_model.EC.turn_on_all(option=False)
                    #            param_model.data_for_plot()
                    #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                    #                                                param_model.total_l, param_model.total_m,
                    #                                                param_model.total_pileup)
                    #            plot_model.show_autofit_opt = False
                    #            plot_model._fig.canvas.draw()
                    #            select_all.text = 'Show All'

                ScrollArea: scr_area:
                    constraints = [height <= 230]

                    Form:
                        row_spacing = -1
                        #padding = Box(0, 0, 0, 0)
                        Looper:
                            iterable << list(param_model.result_dict_names)

                            PushButton: delete_btn:
                                text = 'Del'
                                maximum_size = 30
                                clicked ::
                                    plot_model.remove_peak_manual(loop_item)

                            Container:
                                padding = Box(2, 2, 2, 2)
                                constraints = [hbox(delete_btn, lb_z, lb_name, lb_energy, lb_inten,
                                                    lb_norm, lb_cs, select_cb, spacer),
                                                    lb_norm.height==select_cb.height]

                                Label: lb_z:
                                    text << param_model.EC.element_dict[loop_item].z
                                    minimum_size = (30, 20)
                                    #background = 'white'
                                Label: lb_name:
                                    text << loop_item
                                    minimum_size = (80, 20)
                                    #background = 'white'
                                Label: lb_energy:
                                    text << str(param_model.EC.element_dict[loop_item].energy)
                                    minimum_size = (60, 20)
                                    #maximum_size = 80
                                    #background = 'white'
                                FloatField: lb_inten:
                                    value := param_model.EC.element_dict[loop_item].maxv
                                    minimum_size = (60, 20)
                                    maximum_size = 80
                                    background = 'white'
                                    #align = 'right'
                                    minimum = 0.00001
                                    submit_triggers = ['return_pressed']
                                    value ::
                                        param_model.EC.element_dict[loop_item].maxv = value
                                        # if loop_item == cb_select.selected_item:
                                        #     param_model.add_element_intensity = value
                                        apply_to_fit(param_model, plot_model, fit_model, setting_model)
                                        calculate_spectrum_helper(fit_model, plot_model,
                                                                  param_model, setting_model)
                                Label: lb_norm:
                                    text << set_low_bound(np.around(param_model.EC.element_dict[loop_item].norm, 2))
                                    minimum_size = (60, 20)
                                    #background = 'white'
                                    align = 'center'
                                Label: lb_cs:
                                    text = str(get_cs(loop_item, fit_model.param_dict['coherent_sct_energy']['value']))
                                    minimum_size = (40, 20)
                                CheckBox: select_cb:
                                    checkable = True
                                    minimum_size = (20, 20)
                                    checked := param_model.EC.element_dict[loop_item].status
                                    clicked ::
                                        param_model.EC.element_dict[loop_item].status = checked
                                        param_model.EC.element_dict[loop_item].stat_copy = param_model.EC.element_dict[loop_item].status
                                        #param_model.EC.update_peak_ratio()
                                        #param_model.update_name_list()
                                        param_model.data_for_plot()

                                        plot_model.plot_fit(param_model.prefit_x,
                                                            param_model.total_y,
                                                            param_model.auto_fit_all)
                                        # For plotting purposes, otherwise plot will not update
                                        plot_model.show_fit_opt = False
                                        plot_model.show_fit_opt = True

                PushButton: pb_bound_delete:
                    text = 'Delete Rel Int[%] < '
                    maximum_size = 350
                    visible = True
                    clicked ::
                        param_model.EC.delete_value_given_threshold(threshv=param_model.bound_val)
                        param_model.update_name_list()
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)
                        #param_model.data_for_plot()
                        #plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y, param_model.total_y_l)
                        #plot_model._fig.canvas.draw()
                FloatField: bound_field:
                    value := param_model.bound_val
                    maximum_size = 40
                    minimum = 0.00001
                PushButton: pb_delete_unselected:
                    text = 'Delete Unchecked Items'
                    maximum_size = 350
                    visible = True
                    clicked ::
                        param_model.EC.delete_unselected_items()
                        param_model.update_name_list()
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

                        #param_model.data_for_plot()

                        #plot_model.plot_fit(param_model.prefit_x,
                        #                    param_model.total_y,
                        #                    param_model.auto_fit_all)
                        # For plotting purposes, otherwise plot will not update
                        #plot_model.show_fit_opt = False
                        #plot_model.show_fit_opt = True

                #PushButton: pb_bound:
                #    text = 'Do not plot lines < 0.1%'
                #    maximum_size = 350
                #    visible = True
                #    checkable = True
                #    clicked ::
                #        if checked:
                #            for k,v in six.iteritems(param_model.EC.element_dict):
                #                v.status = v.lbd_stat
                #            param_model.data_for_plot()
                #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y, param_model.total_y_l)
                #            plot_model._fig.canvas.draw()
                #            pb_bound.text = 'Plot lines < 0.1%'
                #        else:
                #            for k,v in six.iteritems(param_model.EC.element_dict):
                #                v.status = v.stat_copy
                #            param_model.data_for_plot()
                #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                #                                       param_model.total_y_l, param_model.total_y_m)
                #            plot_model._fig.canvas.draw()
                #            pb_bound.text = 'Do not plot lines < 0.1%'

                PushButton: pb_update:
                    text = 'Update'
                    clicked ::
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)
                PushButton: pb_undo:
                    text = 'Undo'
                    clicked ::
                        ### This part is similar as importing parameters from file
                        fit_model.default_parameters = fit_model.param_q[0]
                        fit_model.apply_default_param()

                        # update experimental plots
                        plot_model.parameters = fit_model.default_parameters
                        plot_model.plot_experiment()
                        #plot_model.plot_exp_opt = False
                        #plot_model.plot_exp_opt = True

                        # update autofit param
                        param_model.update_new_param(fit_model.default_parameters)
                        #param_model.get_new_param_from_file(parameter_file_path)
                        param_model.update_name_list()
                        param_model.EC.turn_on_all()

                        # update params for roi sum
                        setting_model.update_parameter(fit_model.default_parameters)

                        # calculate profile and plot
                        fit_model.get_profile()

                        # Update displayed intensity of the selected peak
                        plot_model.compute_manual_peak_intensity()

                        # update experimental plot with new calibration values
                        plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                            fit_model.cal_spectrum,
                                            fit_model.residual)
                        # For plotting purposes, otherwise plot will not update
                        if plot_model.plot_exp_opt:
                            plot_model.plot_exp_opt = False
                            plot_model.plot_exp_opt = True
                        else:
                            plot_model.plot_exp_opt = True
                            plot_model.plot_exp_opt = False
                        plot_model.show_fit_opt = False
                        plot_model.show_fit_opt = True

        GroupBox: fit_control:
            title = 'Fit summed spectrum.'
            #padding = Box(2, 2, 2, 2)
            constraints = [
                vbox(
                    gb_advanced,
                    hbox(lbl1, cb1, lbl2, cb2, spacer, pb_save_sum_fit),
                    hbox(pb_fit, gb_result),
                    #gb_result,
                ),
                lbl1.height == cb1.height == lbl2.height,
                lbl2.height == cb2.height,
            ]
            Label: lbl1:
                text = 'Step 1'
            ComboBox: cb1:
                items = [''] + fit_strategy_list
                index = 0
                index := fit_model.fit_strategy1
            Label: lbl2:
                text = 'Step 2'
            ComboBox: cb2:
                items = [''] + fit_strategy_list
                index = 0
                index := fit_model.fit_strategy2
            #Label: lbl3:
            #    text = 'Step 3'
            #ComboBox: cb3:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy3
            #Label: lbl4:
            #    text = 'Step 4'
            #ComboBox: cb4:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy4
            #Label: lbl5:
            #    text = 'Step 5'
            #ComboBox: cb5:
            #    items = [''] + fit_strategy_list
            #    index = 0
            #    index := fit_model.fit_strategy5

            PushButton: pb_fit:
                text = 'Spectrum Fitting'
                clicked ::

                    if param_model.x0 is not None and param_model.y0 is not None:

                        # update parameter for fit
                        #param_model.create_full_param()
                        #fit_model.update_default_param(param_model.param_new)
                        #fit_model.apply_default_param()
                        # The previous 3 lines are replaced by the following
                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

                        #fit_information.text = 'Fitting of summed spectrum starts.'
                        fit_model.fit_multiple()
                        #fit_information.text = 'Fitting of summed spectrum is done!'

                        # BUG: line color for pileup is not correct from fit
                        fit_model.get_profile()

                        # update experimental plot with new calibration values
                        plot_model.parameters = fit_model.param_dict
                        plot_model.plot_experiment()

                        #pb_plot.enabled = True
                        #plot_model.fit_x = fit_model.fit_x
                        #plot_model.fit_y = fit_model.fit_y
                        # BUG!!!
                        #plot_model.fit_all = fit_model.comps
                        #plot_model.fit_all = fit_model.cal_spectrum
                        #plot_model.residual = fit_model.residual
                        #plot_model.plot_fit()

                        plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                                            fit_model.cal_spectrum,
                                            fit_model.residual)

                        # For plotting purposes, otherwise plot will not update
                        plot_model.plot_exp_opt = False
                        plot_model.plot_exp_opt = True
                        plot_model.show_fit_opt = False
                        plot_model.show_fit_opt = True

                        # update autofit param
                        param_model.update_new_param(fit_model.param_dict)
                        #param_model.get_new_param_from_file(parameter_file_path)
                        param_model.update_name_list()
                        param_model.EC.turn_on_all()

                        # update params for roi sum
                        setting_model.update_parameter(fit_model.param_dict)

                        # Update displayed intensity of the selected peak
                        plot_model.compute_manual_peak_intensity()

                        # Amplitude and FWHM may change in the process of fitting. Update the controls.
                        fit_model.update_userpeak_controls()

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or processing parameters are not specified', btns)

            PushButton: pb_save_sum_fit:
                text = 'Save Spectrum/Fit'
                clicked ::
                    fit_model.output_summed_data_fit()
            #Label: fit_information:
            #    text := fit_model.fit_info
            #    foreground = 'red'

            Container: gb_advanced:
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(
                                    hbox(general_set_btn,
                                         element_btn, param_btn, spacer)
                                    )]

                PushButton: element_btn:
                    text = 'Edit Elements'
                    enabled = True
                    checkable = True
                    checked := element_edit.visible
                    clicked ::
                        if checked:
                            element_edit.show()
                        else:
                            element_edit.hide()

                PushButton: param_btn:
                    text = 'Edit Global Fitting Parameters'
                    enabled = True
                    checkable = True
                    checked := parameter_edit.visible
                    clicked ::
                        if checked:
                            parameter_edit.show()
                        else:
                            parameter_edit.hide()

                PushButton: general_set_btn:
                    text = 'General Settings'
                    enabled = True
                    checkable = True
                    checked := othersetting_edit.visible
                    clicked ::
                        if checked:
                            othersetting_edit.show()
                        else:
                            othersetting_edit.hide()

            Container: gb_result:
                #title = 'Fitting Statistics'
                padding = Box(2, 2, 2, 2)
                constraints = [vbox(hbox(lbl_number, lbl_number_v,
                                         lbl_var_number, lbl_var_number_v,
                                         lbl_r2, lbl_r2_v, spacer),
                                    )]
                Label: lbl_number:
                    text = '# of iterations'
                    minimum_size = (60, 16)
                Label: lbl_number_v:
                    text << str(fit_model.function_num)
                    minimum_size = (60, 16)
                Label: lbl_var_number:
                    text = '# of variables'
                    minimum_size = (60, 16)
                Label: lbl_var_number_v:
                    text << str(fit_model.nvar)
                    minimum_size = (60, 16)
                #Label: lbl_chi:
                #    text = 'chi-square'
                #    minimum_size = (60, 16)
                #Label: lbl_chi_v:
                #    text << str(fit_model.chi2)
                #    minimum_size = (60, 16)
                Label: lbl_r2:
                    text = 'R-squared'
                    minimum_size = (60, 16)
                Label: lbl_r2_v:
                    text << str(fit_model.r2)
                    minimum_size = (60, 16)

        GroupBox: gb_fit_pixel:
            title = 'Fit spectrum of all individual pixels.'
            padding = Box(2, 2, 2, 2)
            constraints = [vbox(hbox(save_cb, lb1, fd1v, fd1h, lb2, fd2v, fd2h, spacer, interp_cb),
                                hbox(fit_pixel, spacer, save_q_standard_btn, to_db, output_btn, to_tiff, to_txt))]
            CheckBox: save_cb:
                text = 'Save plots'
                clicked ::
                    if checked:
                        fit_model.save_point = True
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
                    else:
                        fit_model.save_point = False
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
            Label: lb1:
                text = 'Start Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd1v:
                value := fit_model.point1v
                maximum_size = 40
                enabled = False
            IntField: fd1h:
                value := fit_model.point1h
                maximum_size = 40
                enabled = False
            Label: lb2:
                text = 'End Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd2v:
                value := fit_model.point2v
                maximum_size = 40
                enabled = False
            IntField: fd2h:
                value := fit_model.point2h
                maximum_size = 40
                enabled = False

            CheckBox: interp_cb:
                text = 'Interpolation with x,y'
                checked := fit_model.map_interpolation

            PushButton: fit_pixel:
                text = 'Individual Pixel Fitting'
                clicked ::

                    if param_model.x0 is not None and param_model.y0 is not None:

                        apply_to_fit(param_model, plot_model, fit_model, setting_model)

                        fit_model.fit_single_pixel()
                        # add scalers to fit dict
                        scaler_key = [v for v in six.iterkeys(img_model_adv.data_dict) if 'scaler' in v]
                        if len(scaler_key) > 0:
                            fit_model.fit_img[list(fit_model.fit_img.keys())[0]].update(img_model_adv.data_dict[scaler_key[0]])

                        img_model_adv.data_dict.update(fit_model.fit_img)
                        img_model_rgb.data_dict.update(fit_model.fit_img)
                        img_model_adv.set_default_dict(img_model_adv.data_dict)

                        # visualization purpose
                        img_model_adv.data_dict_keys = []
                        img_model_adv.data_dict_keys = list(img_model_adv.data_dict.keys())
                        img_model_rgb.data_dict_keys = []
                        img_model_rgb.data_dict_keys = list(img_model_rgb.data_dict.keys())

                    else:

                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Experimental data is not loaded or processing parameters are not specified', btns)

            #Label: pixel_fit_information:
            #    text := fit_model.pixel_fit_info
            #    foreground = 'red'

            PushButton: save_q_standard_btn:
                text = 'Save Q. Standard'
                # Disable the button is enabled only if the standard is loaded
                enabled << bool(fit_model.qe_standard_selected_copy)
                clicked ::
                    result_map, scaler_name = fit_model.get_latest_single_pixel_fitting_data()
                    selected_det_channel = io_model.get_selected_detector_channel()
                    if not result_map:
                        btns = [DialogButton('Ok', 'accept')]
                        critical(self, 'ERROR', f'No XRF maps were found. Run Individual Pixel Fitting to generate XRF maps.', btns)
                    else:
                        fit_model.qe_standard_path_name = io_model.working_directory + "/"
                        fit_model.qe_standard_file_name = fit_model.param_quant_estimation.get_suggested_json_fln()

                        # Fill the available fluorescence data
                        fit_model.param_quant_estimation.fill_fluorescence_data_dict(
                            xrf_map_dict=result_map, scaler_name=scaler_name)
                        fit_model.param_quant_estimation.set_detector_channel_in_data_dict(
                            detector_channel=selected_det_channel)

                        fit_model.param_quant_estimation.set_distance_to_sample_in_data_dict(
                            distance_to_sample=fit_model.get_qe_standard_distance_as_float())

                        # Set optional parameters
                        if io_model.scan_metadata_available:
                            _scan_id = None
                            _scan_uid = None
                            if "scan_id" in io_model.scan_metadata:
                                _scan_id = io_model.scan_metadata["scan_id"]
                            if "scan_uid" in io_model.scan_metadata:
                                _scan_uid = io_model.scan_metadata["scan_uid"]
                            fit_model.param_quant_estimation.set_optional_parameters(
                                scan_id=_scan_id, scan_uid=_scan_uid)

                        fit_model.qe_standard_data_preview = \
                            fit_model.param_quant_estimation.get_fluorescence_data_dict_text_preview()

                        if save_quant_calibration_edit.exec_():
                            try:
                                # Create full path to file
                                fln_json = fit_model.qe_standard_file_name.strip()
                                path_json = os.path.join(io_model.working_directory, fln_json)

                                fit_model.param_quant_estimation.save_fluorescence_data_dict(path_json,
                                    overwrite_existing=fit_model.qe_standard_overwrite_existing)

                                print(f"Quantitative calibration is saved successfully to the file '{path_json}'")

                            except Exception as ex:
                                btns = [DialogButton('Ok', 'accept')]
                                critical(self, 'ERROR', f'Failed to save quantitative calibration: {ex}', btns)

                        # If the checkbox is set True in 'save_quant_calibration_edit', reset it to False
                        #   This checkbox is a safety feature, and should be checked each time the
                        #   Dialog Box is opened (for each new file, or each attempt to save the same file)
                        fit_model.qe_standard_overwrite_existing = False


            PushButton: to_db:
                text = 'Save to DB'
                enabled = False  # Disable this button (database for processing data does not exist yet)
                #enabled = databroker is not None
                #minimum_size = (20, 20)
                clicked ::
                    fit_model.save_pixel_fitting_to_db()

            PushButton: output_btn:
                text = 'Output setup'
                enabled = True
                checkable = True
                checked := output_edit.visible
                clicked ::
                    if checked:
                        output_edit.show()
                    else:
                        output_edit.hide()

            PushButton: to_tiff:
                text = 'Save to tiff'
                #minimum_size = (20, 20)
                clicked ::
                    try:
                        fit_model.output_2Dimage()
                    except Exception as ex:
                        btns = [DialogButton('Ok', 'accept')]
                        critical(self, 'ERROR', f"Error occurred while saving data to TIFF files: {ex}", btns)
                    else:
                        logger.info("Data was successfully saved to TIFF files")

            PushButton: to_txt:
                text = 'Save to txt'
                #minimum_size = (20, 20)
                clicked ::
                    try:
                        fit_model.output_2Dimage(to_tiff=False)
                    except Exception as ex:
                        btns = [DialogButton('Ok', 'accept')]
                        critical(self, 'ERROR', f"Error occurred while saving data to TEXT files: {ex}", btns)
                    else:
                        logger.info("Data was successfully saved to TEXT files")


enamldef SelectStandard(Dialog): select_standard_win:
    attr fit_model

    title = "Select Quantitative Standard"
    initial_size = (500, 600)

    Container:
        constraints = [vbox(
            scr_area,
            hbox(spacer, select_btn, cancel_btn),
        )]

        ScrollArea: scr_area:
            #constraints = [height <= 230]

            Form:
                row_spacing = 15
                #padding = Box(0, 0, 0, 0)

                Looper:

                    iterable << fit_model.qe_param_custom_ref

                    RadioButton: select_btn:
                        text = ''
                        checked << loop_item == fit_model.qe_standard_selected_ref
                        clicked ::
                            fit_model.qe_standard_selected_ref = loop_item

                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [vbox(
                            hbox(select_btn,
                                 vbox(hbox(standard_info_serial, spacer),
                                      hbox(standard_info_name, spacer),
                                      hbox(standard_info_description, spacer)),
                            spacer)), align("top", select_btn, standard_info_serial)]


                        Label: standard_info_serial:
                            text << f"Serial Number: {loop_item['serial']}" + " (user-defined)"

                        Label: standard_info_name:
                            text << f"Name: {loop_item['name']}"

                        Label: standard_info_description:
                            text << f"Description: {loop_item['description']}"

                Looper:
                    iterable << fit_model.qe_param_built_in_ref

                    RadioButton: select_btn:
                        text = ''
                        # The item should not be 'checked' if the same standard is present
                        #   in the list of custom (user-defined) standards. User-defined
                        #   standards have priority over built-in standards to be 'checked'.
                        checked << (loop_item == fit_model.qe_standard_selected_ref) and \
                            not fit_model.param_quant_estimation.is_standard_custom(loop_item)
                        clicked ::
                            fit_model.qe_standard_selected_ref = loop_item

                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [vbox(
                            hbox(select_btn,
                                 vbox(hbox(standard_info_serial, spacer),
                                      hbox(standard_info_name, spacer),
                                      hbox(standard_info_description, spacer)),
                            spacer)), align("top", select_btn, standard_info_serial)]


                        Label: standard_info_serial:
                            text << f"Serial Number: {loop_item['serial']}"

                        Label: standard_info_name:
                            text << f"Name: {loop_item['name']}"

                        Label: standard_info_description:
                            text << f"Description: {loop_item['description']}"


        PushButton: select_btn:
            text = "Select"
            clicked ::
                 select_standard_win.accept()

        PushButton: cancel_btn:
            text = "Cancel"
            clicked ::
                 select_standard_win.reject()


enamldef SaveQuantCalibration(Dialog): save_quant_calibration_dialog:

    attr fit_model

    title = "Save Quantitative Calibration"
    initial_size = (500, 600)

    Container:
        constraints = [vbox(
            hbox(data_preview_lb),
            hbox(data_preview_mf),
            hbox(file_path_lb, file_name_fld),
            hbox(dist_to_sample_lb, dist_to_sample_fld, spacer, overwrite_cb),
            hbox(spacer, save_btn, cancel_btn),
        ), align("v_center", file_path_lb, file_name_fld)]

        Label: data_preview_lb:
            text = "The following data will be saved to the JSON file:"

        MultilineField: data_preview_mf:
            read_only = True
            text << fit_model.qe_standard_data_preview

        Label: file_path_lb:
            text << f"Full file name: {fit_model.qe_standard_path_name}"

        Field: file_name_fld:
            text := fit_model.qe_standard_file_name

        Label: dist_to_sample_lb:
            text = "Distance to sample: "

        FloatField: dist_to_sample_fld:
            text := fit_model.qe_standard_distance

        CheckBox: overwrite_cb:
            text = "Overwrite existing file"
            checked := fit_model.qe_standard_overwrite_existing

        PushButton: save_btn:
            text = "Save"
            clicked ::
                 save_quant_calibration_dialog.accept()

        PushButton: cancel_btn:
            text = "Cancel"
            clicked ::
                 save_quant_calibration_dialog.reject()


enamldef OutputSetup(Window): output_win:
    attr fit_model

    Container:
        constraints = [vbox(gb_range, save_btn),]

        #GroupBox: gb_norm:
        #    constraints = [vbox(lbl_norm, cmb_scaler),]
        #    Label: lbl_norm:
        #        text = 'Output data with normalization'
        #    ComboBox: cmb_scaler:
        #        items << ['Normalized by'] + fit_model.scaler_keys
        #        index >> fit_model.scaler_index
        #        index = 0

        GroupBox: gb_range:
            constraints = [vbox(cb1, hbox(lbl_low, ff_low),
                                hbox(lbl_high, ff_high),)]
            CheckBox: cb1:
                text = 'Calculate ROI sum within given range (KeV)'
                checked := fit_model.roi_sum_opt['status']
            Label: lbl_low:
                text = 'low range'
            FloatField: ff_low:
                value := fit_model.roi_sum_opt['low']
            Label: lbl_high:
                text = 'high range'
            FloatField: ff_high:
                value := fit_model.roi_sum_opt['high']
        PushButton: save_btn:
            text = 'Save'
            clicked ::
                fit_model.calculate_roi_sum()
                output_win.close()


enamldef AutoFindElements(Window): auto_win:
    attr parameter_model
    attr plot_model
    title = 'Automated Element Search'
    destroy_on_close = False

    Container:
        #padding = Box(2, 2, 2, 2)
        constraints = [
            vbox(
                hbox(param_form),
                hbox(find_btn, spacer),
            ),
        ]
        #title = 'Or use automatic element finding to get elements.'
        #ScrollArea: top_cntr:
        #constraints = [height <= 80]
        Form: param_form:
            row_spacing = -1
            Looper:
                #iterable << sorted([v for k,v in six.iteritems(param_model.param_new) if v.get('description')],
                #                   key=lambda x: x['description'])
                iterable << autofit_param
                Label:
                    text = param_model.param_new[loop_item]['description']
                    #tool_tip = loop_item['tool_tip']
                    maximum_size = 140
                Container:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff, pb_value_default)]
                    FloatField: ff:
                        value := param_model.param_new[loop_item]['value']
                        maximum_size = 160
                    PushButton: pb_value_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff.value = param_model.param_new[loop_item]['default']

            Looper:
                iterable << [param_model.param_new[k] for k in ('coherent_sct_energy',)]
                Label:
                    text = loop_item['description']
                    maximum_size = 140
                Container: cont:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff_incident_energy, pb_bd_default)]
                    FloatField: ff_incident_energy:
                        value := plot_model.incident_energy
                        value ::
                            io_model.incident_energy_set = value
                        maximum_size = 100
                    PushButton: pb_bd_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff_incident_energy.value = loop_item['default_value']

            Looper: 
                iterable << [param_model.param_new['non_fitting_values'][k] for k in ('energy_bound_high',)]
                Label:
                    text = loop_item['description']
                    maximum_size = 140
                Container: cont:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff_bound_high, pb_bd_default)]
                    FloatField: ff_bound_high:
                        value := param_model.energy_bound_high_buf
                        maximum_size = 100
                    PushButton: pb_bd_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff_bound_high.value = loop_item['default_value']

            Looper: 
                iterable << [param_model.param_new['non_fitting_values'][k] for k in ('energy_bound_low',)]
                Label:
                    text = loop_item['description']
                    maximum_size = 140
                Container:
                    padding = Box(2, 2, 2, 2)
                    constraints = [hbox(ff_bound_low, pb_bd_default)]
                    FloatField: ff_bound_low:
                        value := param_model.energy_bound_low_buf
                        maximum_size = 100
                    PushButton: pb_bd_default:
                        text = 'Default'
                        maximum_size = 100
                        clicked ::
                            ff_bound_low.value = loop_item['default_value']


        PushButton: find_btn:
            text = 'Find Elements'
            enabled = True
            clicked ::
                param_model.find_peak()
                param_model.EC.order()
                param_model.update_name_list()

                param_model.EC.turn_on_all()
                param_model.data_for_plot()

                # update experimental plots in case the coefficients change
                plot_model.parameters = param_model.param_new
                plot_model.plot_experiment()

                plot_model.plot_fit(param_model.prefit_x,
                                    param_model.total_y,
                                    param_model.auto_fit_all)

                # Update displayed intensity of the selected peak
                plot_model.compute_manual_peak_intensity()

                # Show the summed spectrum used for fitting
                plot_model.plot_exp_opt = False
                plot_model.plot_exp_opt = True
                # For plotting purposes, otherwise plot will not update
                plot_model.show_fit_opt = False
                plot_model.show_fit_opt = True
                auto_win.close()


def sorted_param(param_model):
    return list(([v for k,v in six.iteritems(param_model.param_new['non_fitting_values']) if k in ["energy_bound_low", "energy_bound_high"] ]))


enamldef ElementEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model

    title = "Edit Fitting Parameters for Selected Emission Lines"

    Container:
        constraints = [vbox(hbox(cal_pbn, spacer),
                            cmb_element,
                            hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        padding = Box(5, 5, 5, 5)

        PushButton: cal_pbn:
            text = 'Update and Plot'
            clicked ::
                calculate_spectrum_helper(fit_model, plot_model,
                                          param_model, setting_model)

        ComboBox: cmb_element:
            items << ['Select Element'] + fit_model.element_list
            index = 0
            index := fit_model.selected_index
            #selected_item >> fit_model.selected_element
        Label: lbl1:
            text = '{:>20} {:>20} {:>26} {:>26} {:>26} {:>16}'.format('name','energy', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]

        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper:
                    #iterable << sorted([k for k in six.iterkeys(fit_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    #iterable << list(sorted([v for v in six.iterkeys(fit_model.param_dict) if cmb_element.selected_item.split('_')[0] in str(v)]))
                    iterable << fit_model.elementinfo_list

                    Label: name_lbl:
                        text << loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        constraints = [hbox(
                            energy_v, ff_value, ff_min, ff_max,
                            cb_strat0, cb_strat1, cb_strat2,
                            cb_strat3, cb_strat4, cb_strat5, cb_strat6, spacer)
                        ]
                        Label: energy_v:
                            text = get_energy(loop_item)
                            minimum_size = (50, 20)
                        FloatField: ff_value:
                            value := fit_model.param_dict[loop_item]['value']
                            #minimum = fit_model.param_dict[loop_item]['min']
                            #maximum = fit_model.param_dict[loop_item]['max']
                        FloatField: ff_min:
                            value := fit_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := fit_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.selected_item  #items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef ParameterEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model

    destroy_on_close = False
    Container:
        constraints = [vbox(hbox(cal_pbn, spacer),
                            hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        #padding = Box(5, 5, 5, 5)
        PushButton: cal_pbn:
            text = 'Update & Plot'
            clicked ::
                calculate_spectrum_helper(fit_model, plot_model,
                                          param_model, setting_model)
        Label: lbl1:
            #text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
            text = '{:>16} {:>42} {:>32} {:>32} {:>16}'.format('name', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]
        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper:
                    #iterable << sorted([k for k in six.iterkeys(fit_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    iterable << fit_model.global_param_list
                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [hbox(ff_value, ff_min, ff_max, cb_strat0, cb_strat1, cb_strat2, cb_strat3,
                                            cb_strat4, cb_strat5, cb_strat6,spacer)]
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        FloatField: ff_value:
                            value := fit_model.param_dict[loop_item]['value']
                            minimum_size = (150, 20)
                        FloatField: ff_min:
                            value := fit_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := fit_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(fit_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    fit_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef OtherSettingEdit(Window):
    attr fit_model
    attr param_model
    attr plot_model
    attr setting_model

    Container :
        DockArea :
            layout = TabLayout('item_bkg', 'item_controller', 'item_controller_pixel')
            DockItem:
                closable = False
                name = 'item_bkg'
                title = 'Background/Escape'
                Container:
                    Form:
                        Label:
                            text = 'Background width'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['background_width']
                        Label:
                            text = 'Escape peak'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['escape_ratio']
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                calculate_spectrum_helper(fit_model, plot_model,
                                                          param_model, setting_model)
                        Label:
                            pass

            DockItem:
                closable = False
                name = 'item_controller'
                title = 'Fitting Controller for Summed Spectrum'
                Container:
                    Form:
                        Label:
                            text = 'Max iteration number'
                        IntField:
                            value := fit_model.fit_num
                        Label:
                            text = 'Convergence criterion'
                        FloatField:
                            value := fit_model.ftol
                        Label:
                            text = 'Lower bound'
                        FloatField:
                            value := param_model.energy_bound_low_buf
                            # value := fit_model.param_dict['non_fitting_values']['energy_bound_low']['value']
                        Label:
                            text = 'Higher bound'
                        FloatField:
                            value := param_model.energy_bound_high_buf
                            # value := fit_model.param_dict['non_fitting_values']['energy_bound_high']['value']
                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                calculate_spectrum_helper(fit_model, plot_model,
                                                          param_model, setting_model)
                        Label:
                            pass

            DockItem:
                closable = False
                name = 'item_controller_pixel'
                title = 'Fitting Controller for Single Pixels'
                Container:
                    Form:
                        Label:
                            text = 'Select fitting algorithm'
                        ComboBox: cb_algorithm:
                            items = ['non-negative leastsq', 'nonlinear leastsq']
                            index := fit_model.pixel_fit_method
                            #index ::
                            #    if index == 0:
                            #        fit_model.pixel_fit_method = 0
                            #    if index == 1:
                            #        fit_model.pixel_bin = 4
                        #Label:
                        #    text = 'Max iteration number'
                        #IntField:
                        #    value := fit_model.fit_num
                        #Label:
                        #    text = 'Convergence criterion'
                        #FloatField:
                        #    value := fit_model.ftol
                        Label:
                            text = 'Add const to background'
                        FloatField:
                            value := fit_model.raise_bg
                        Label:
                            text = 'Bin data on x,y positions'
                        ComboBox: cb_bin:
                            items = ['0', '2 by 2', '3 by 3']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.pixel_bin = 0
                                if index == 1:
                                    fit_model.pixel_bin = 4
                                if index == 2:
                                    fit_model.pixel_bin = 9
                        Label:
                            text = 'Use linear background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 1
                            index ::
                                if index == 0:
                                    fit_model.linear_bg = True
                                else:
                                    fit_model.linear_bg = False
                        Label:
                            text = 'Use snip method for background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.use_snip = True
                                else:
                                    fit_model.use_snip = False
                        Label:
                            text = 'Bin data on energy axis'
                        ComboBox:
                            items = ['0', '2', '3']
                            index = 0
                            index ::
                                fit_model.bin_energy = int(selected_item)

                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight
                        PushButton:
                            text = 'Apply'
                            clicked ::
                                pass
                        Label:
                            pass

            #DockItem:
            #    closable = False
            #    name = 'pileup'
            #    title = 'Pileup Peak'
            #    Container:
            #        Form:
            #            Label: e1:
            #                text = 'Element1, i.e. Si_Ka1'
            #            Field: fd1:
            #                text = ''
            #            Label: e2:
            #                text = 'Element2, i.e. Fe_Ka1'
            #            Field: fd2:
            #                text = ''
            #            #Label: intensity:
            #            #    text = 'Peak Int'
            #            #FloatField: intensity_ff:
            #            #    pass
            #            PushButton: add_btn:
            #                text = 'Apply'
            #                clicked ::
            #                    fit_model.pileup_data['element1'] = fd1.text
            #                    fit_model.pileup_data['element2'] = fd2.text
            #                    #fit_model.pileup_data['intensity'] = intensity_ff.value
            #                    fit_model.add_pileup()
            #                    fit_model.update_name_list()
            #                    calculate_spectrum_helper(fit_model, plot_model, param_model)
            #            Label:
            #                pass


def save_defaults(parameter_model):
    user_path = os.path.join(os.path.expanduser('~'), '.pyxrf',
                             'xrf_parameter_user.json')
    # format the dictionary
    dct = format_dict(parameter_model.parameters, parameter_model.element_list)
    json_out = json.dumps(dct)
    with open(user_path, 'w') as out_file:
        out_file.write(json_out)


enamldef EditPileupPeak(Window): pileup_win:
    attr param_model
    attr plot_model
    destroy_on_close = False
    title = 'Add Pileup Peak'
    Container:
        Form:
            Label: e1:
                text = 'Element1, i.e. Si_Ka1'
            Field: fd1:
                text = ''
            Label: e2:
                text = 'Element2, i.e. Fe_Ka1'
            Field: fd2:
                text = ''
            Label: intensity:
                text = 'Peak Int'
            FloatField: intensity_ff:
                pass
            PushButton: add_btn:
                text = 'Add'
                maximum_size = 60
                clicked ::
                    try:
                        param_model.pileup_data['element1'] = fd1.text
                        param_model.pileup_data['element2'] = fd2.text
                        param_model.pileup_data['intensity'] = intensity_ff.value

                        peak_name = param_model.generate_pileup_peak_name()
                        if not param_model.EC.is_element_in_list(peak_name):

                            param_model.add_pileup()
                            param_model.EC.update_peak_ratio()
                            param_model.update_name_list()
                            param_model.data_for_plot()

                            plot_model.plot_fit(param_model.prefit_x,
                                                param_model.total_y,
                                                param_model.auto_fit_all)
                            # For plotting purposes, otherwise plot will not update
                            plot_model.show_fit_opt = False
                            plot_model.show_fit_opt = True
                            pileup_win.close()

                        else:

                            btns = [DialogButton('Ok', 'accept')]
                            # 'critical' shows MessageBox
                            critical(self, 'ERROR', f'Element emission line {peak_name} is already selected', btns)

                    except Exception:
                        btns = [DialogButton('Ok', 'accept')]
                        # 'critical' shows MessageBox
                        critical(self, 'ERROR', f'Unknown element emission lines or non-positive peak intensity', btns)

def set_low_bound(value, thresh_v=0.1):
    """
    Return values only above given threshold.

    Parameters
    ----------
    value : float
    thresh_v : float, opt
        threshold value
    """
    if value <= thresh_v:
        return '< {}'.format(thresh_v)
    else:
        return str(value)


def calculate_spectrum_helper(fit_model, plot_model,
                              param_model, setting_model):
    """
    Calculate spectrum, and update plotting and param_model.
    """
    if fit_model.x0 is None or fit_model.y0 is None:
        return

    fit_model.get_profile()

    # update experimental plot with new calibration values
    plot_model.parameters = fit_model.param_dict
    plot_model.plot_experiment()

    plot_model.plot_fit(fit_model.cal_x, fit_model.cal_y,
                        fit_model.cal_spectrum,
                        fit_model.residual)

    # For plotting purposes, otherwise plot will not update
    plot_model.show_fit_opt = False
    plot_model.show_fit_opt = True

    # update autofit param
    param_model.update_new_param(fit_model.param_dict)
    #param_model.get_new_param_from_file(parameter_file_path)
    param_model.update_name_list()
    param_model.EC.turn_on_all()

    # update params for roi sum
    setting_model.update_parameter(fit_model.param_dict)


def apply_to_fit(param_model, plot_model,
                 fit_model, setting_model):
    """
    Update plot, and apply updated parameters to fitting process.
    """
    #param_model.update_name_list()
    param_model.EC.update_peak_ratio()
    param_model.data_for_plot()

    # update experimental plots in case the coefficients change
    plot_model.parameters = param_model.param_new
    plot_model.plot_experiment()

    plot_model.plot_fit(param_model.prefit_x,
                        param_model.total_y,
                        param_model.auto_fit_all)

    # For plotting purposes, otherwise plot will not update

    if plot_model.plot_exp_opt:
        plot_model.plot_exp_opt = False
        plot_model.plot_exp_opt = True
    else:
        plot_model.plot_exp_opt = True
        plot_model.plot_exp_opt = False
    plot_model.show_fit_opt = False
    plot_model.show_fit_opt = True

    # update parameter for fit
    param_model.create_full_param()
    fit_model.update_default_param(param_model.param_new)
    fit_model.apply_default_param()

    # update params for roi sum
    setting_model.update_parameter(fit_model.param_dict)

    # Update displayed intensity of the selected peak
    plot_model.compute_manual_peak_intensity()


def get_energy(name):
    """
    Calculate emission line for given element name.
    """
    if 'pileup' in name or 'user' in name.lower():  # for pileup peak
        return '-'
    name_list = name.split('_')
    e = Element(name_list[0])
    return str(np.around(e.emission_line[name_list[1]], decimals=4))
